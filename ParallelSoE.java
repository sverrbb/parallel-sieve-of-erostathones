
import java.util.concurrent.CyclicBarrier;

/**
 * Parallel version of Sieve Of Eratosthenes
 */
public class ParallelSoE {

    int[] primes;
    byte[] oddNumbers;
    int[][] primeList;
    CyclicBarrier cb1, cb2;
    int n, k, root, primeNumbers, len, counter;

    /**
     * Constructor, takes in to arguments n and k
     * N - generate alle prime number up to N
     * K - number of threads to be used in parallelization
     */
    public ParallelSoE(int n, int k) {
      this.n = n;
      this.k = k;
      oddNumbers = new byte[(n / 16) + 1];
      root = (int) Math.sqrt(n);
      cb1 = new CyclicBarrier(k + 1);
      cb2 = new CyclicBarrier(k);
      primeList = new int[k][];
    }


    /**
     * Create k threads and conducts the parallel sieve
     * Returns an array containing the primes generated
     */
    public int[] getPrimes() {
      sieve();
      int firstByte = root / 16;
      int segmentSize = ((n / 16 + 1) - firstByte) / k;
      int remainder = ((n / 16 + 1) - firstByte)  % k;
      int start = firstByte;
      int end;

      for (int i = 0; i < remainder; i++) {
        end = start + segmentSize + 1;
        new Thread(new Worker(i, start, end)).start();
        start += segmentSize + 1;
      }

      for (int i = remainder; i < k; i++) {
        end = start + segmentSize;
        new Thread(new Worker(i, start, end)).start();
        start += segmentSize;
      }
      
      try {
        cb1.await();
      } catch (Exception e) {
        e.printStackTrace();
      }

      // Gather alle primes generated by threads and collect in array primes
      int counter = 0;
      for(int j = 0; j < primeList.length; j++){
        for(int k = 0; k < primeList[j].length; k++){
          primes[counter] = primeList[j][k];
          counter++;
        }
      }
      // Returns array 'primes'
      primes[0] = 2;
      return primes;
    }


    /**
     * Checks if number is prime number
     * return true or false depending on result
     */
    private boolean isPrime(int num) {
      if ((num & 1) == 0) return false;
      int byteIndex = num / 16;
      int bitIndex = (num / 2) % 8;
      return (oddNumbers[byteIndex] & (1 << bitIndex)) == 0;
    }


    /**
     * Performes the sieve
     */
    private void sieve() {
      primeNumbers = 1;
      int prime = nextPrime(1);
      while (prime != -1) {
        traverse(prime);
        prime = nextPrime(prime);
        primeNumbers++;
      }
    }

    /**
     * Marks all odd number multiples of 'prime', starting from prime * prime.
     * prime - the prime used to mark the composite numbers.
     */
    private void traverse(int prime) {
      for (int i = prime * prime; i <= root; i += prime * 2)
        mark(i);
    }


    /**
     * Marks the 'num' as non-prime
     * num - number to be marked non-prime.
     */
    public void mark(int num) {
      int bitIndex = (num % 16) / 2;
      int byteIndex = num / 16;
      oddNumbers[byteIndex] |= (1 << bitIndex);

    }


    /**
     * Finds next prime in sequence
     */
    public int nextPrime(int prev) {
      for (int i = prev + 2; i < root; i += 2) {
          if (isPrime(i)) {
              return i;
          }
      }
      return -1;
    }



    /**
     * Inner worker class used by threads for generating prime numbers
     */
    class Worker implements Runnable {
        int id;
        int start;
        int end;

        /**
         * Constructor - takes in three arguments
         * id - unique number for each thread
         * start - start number for worker
         * end - end number for worker
         */
        Worker(int id, int start, int end) {
          this.id = id;
          this.end = end;
          this.start = start;
        }

        /**
         * Run method called by each thread
         */
        public void run() {
          traverse();
          int[] threadPrimes = gatherPrimes();
          len += threadPrimes.length;
          primeList[id] = threadPrimes;
          try {
              cb2.await();
          } catch(Exception e) {
            e.printStackTrace();
          }
          // Wait for the threads to synchroinize and
          // initialize the prime array with the length calculated
          if (id == 0){
            primes = new int[len];
          }
          try {
            cb1.await();
          } catch(Exception e) {
            e.printStackTrace();
          }
        }


        /**
         * Traverse and mark multiples in segment for thread
         */
        private void traverse() {
          calculateThreadValues();
          // get first prime and calculate first and last value
          int prime = nextPrime(1);
          int first = getFirst(start, prime);
          int last = getLast(end, prime);

          while ((prime != 0 && prime <= root) && notMax(prime)) {
              //traverse - mark miltiples of first x prime, up to end
              for (int i = first * prime; i < end; i += prime * 2) {
                  mark(i);
              }
              // get next prime and calculate new start and end value
              prime = nextPrime(prime);
              if (prime == -1) break;
              first = getFirst(start, prime);
              last = getLast(end, prime);
          }
        }



        // Used for calculating 'first' value in travers method
        private int getFirst(int start, int prime){
          int first = (start + prime - 1) / prime;
          first = (prime < first) ? first : prime;
          if ((first & 1) == 0) first++;
          return first;
        }


        // Used for calculating 'last' value in travers method
        private int getLast(int end, int prime){
          int last = (end- 2) / prime;
          if ((last & 1) == 0) last--;
          return last;
        }


        // Calcualte start and end value for thread
        private void calculateThreadValues(){
          start = start * 16 + 1;
          end = end * 16 + 1;
          // Last thread
          if (id == k - 1){
            end = ((n & 1) == 0) ? n+1 : n+2;
          }
        }


        /**
         * Checks for max value
         */
        private boolean notMax(int prime){
          return prime * prime <= end - 2;
        }


        /**
         * Gather primes for each thread
         * Returns a local array containing the primes
         */
        private int[] gatherPrimes() {
          // Count number of primes for thread
          int counter = 0;
          for (int number = (id == 0) ? 1 : start; number < end; number++) {
            if(isPrime(number)) {
              counter++;
            }
          }
          // initialize array and fill up with primes
          int[] threadPrimes = new int[counter];
          int index = 0;
          for (int number = (id == 0) ? 1 : start; number < end && index < counter; number++) {
            if(isPrime(number)){
              threadPrimes[index] = number;
              index++;
            }

          }
          return threadPrimes;
        }
    }
}
